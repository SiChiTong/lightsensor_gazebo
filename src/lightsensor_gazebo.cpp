/**
 * @file lightsensor_gazebo_node.cpp
 * @brief  Brief description of file.
 *
 */

#include "ros/ros.h"
#include "gazebo/gazebo.hh"
#include "gazebo/physics/physics.hh"
#include "gazebo/common/common.hh"
#include <diamondapparatus/diamondapparatus.h>

#include "lightsensor_gazebo/LightSensor.h"
const double PI = 3.1415927;

// powerin values
double getBrightTable(double dist){
    static const int buckets=100;
    static const double table[100]={
17.962877,17.528015,16.865154,15.304620,13.964255,
13.840416,11.753480,12.208778,10.979894,10.331553,
10.481823,10.653681,10.877003,11.074194,11.113714,
10.903679,10.261866,10.182056,9.862350,9.507373,
9.377901,9.164327,9.251522,9.100354,9.068455,
8.895081,8.863251,8.788433,8.596110,8.429076,
8.455504,8.277542,8.212848,8.054348,8.051748,
7.953949,7.897304,7.779781,7.623307,7.512770,
7.383260,7.416339,7.313428,7.377044,7.213720,
7.108899,7.078441,7.003161,6.902228,6.792324,
6.834842,6.832661,6.643435,6.625330,6.578120,
6.568528,6.508955,6.371882,6.424756,6.360265,
6.286812,6.189941,6.011896,6.006203,6.014493,
5.929008,5.952468,5.902879,5.830948,5.780528,
5.754826,5.636479,5.541299,5.631682,5.463408,
5.517048,5.324142,5.407453,5.399677,5.356863,
5.135526,5.143912,4.932515,5.148232,5.079886,
5.098643,5.141450,4.881382,5.091868,5.005826,
5.047245,5.166583,4.995914,5.040800,4.956200,
4.926520,4.863213,4.712200,4.637655,4.308120
    };

    static const double mindist = 0.179183;
    static const double maxdist = 3.366259;
    double v;
    if(dist>maxdist){
        v=table[buckets-1];
        printf("SNARK dist=%f,v=%f\n",dist,v);
    }
    else if(dist<mindist)v=table[0];
    else {
        dist -= mindist;
        dist /= (maxdist-mindist) ;
        dist *= (double)buckets;
        v = table[(int)dist];
    }
    
    // is already divided by kpower in the LUT, so
    // just return - will be multiplied by kpower
    // to form powerin in the node.
    return v;
}


// blur code copied from bridgeserver and modified
// for doubles. Should have templated it.

// Normalized 1D Gaussian kernel for sigma=2.000000, size=11
// Generated by gengauss.ang
#define KSIZE 11
#define HALFK ((KSIZE-1)/2)
float k[] = {0.200565,0.176998,0.121649,0.065114,0.027144,0.008812};
//float k[] = {1,0,0,0,0,0};

void blur(double *out,double *p,int ch,int n){
    double mx=0;
    for(int i=0;i<n;i++){
        double t = 0;
        for(int j=-HALFK;j<=HALFK;j++){
            int px = (i+j+n)%n;
            t+= p[px*3+ch]*k[j<0?-j:j];
        }
        t /= (double)KSIZE;
        out[i*3+ch]=t;
        if(mx>t)mx=t;
    }
    return;    
    /*
    // now normalize the values to [0-1]
    double normfac = 1.0/mx;
    for(int i=0;i<n;i++){
        out[i*3+ch]*=normfac;
       }
     */
}

namespace gazebo {

class LightSensor : public ModelPlugin {
public:
    LightSensor(){
        pixelStore = NULL;
    }
    
    virtual ~LightSensor(){
        if(pixelStore){
            delete[] pixelStore;
            delete[] blurbuf;
        }
    }
private:
    
    bool updateOK;
    // the timer sets updateOK, so that the update event is permitted
    // to do its stuff
    void timerCallback(const ros::TimerEvent&){
        updateOK=true;
    }
    
protected:    
    virtual void Load(physics::ModelPtr _model,sdf::ElementPtr _sdf){
        updateOK=false;
        // Make sure the ROS node for Gazebo has already been initialized
        if (!ros::isInitialized())
        {
            ROS_FATAL_STREAM("A ROS node for Gazebo has not been initialized, unable to load plugin. "
                             << "Load the Gazebo system plugin 'libgazebo_ros_api_plugin.so' in the gazebo_ros package.");
            return;
        }
        
        model = _model;
        world = _model->GetWorld();
        
        diamondapparatus::init();
        
        // load parameters
        if (_sdf->HasElement("robotNamespace"))
            namespc = _sdf->GetElement("robotNamespace")->GetValue()->GetAsString();
        else
            namespc.clear();
        
        if (_sdf->HasElement("bodyName"))
        {
            linkname = _sdf->GetElement("bodyName")->GetValue()->GetAsString();
            link = _model->GetLink(linkname);
        }
        else
        {
            link = _model->GetLink();
            linkname = link->GetName();
        }
        
        // assert that the body by link_name_ exists
        if (!link)
        {
            ROS_FATAL("lightsensor_gazebo plugin error: bodyName: %s does not exist\n", linkname.c_str());
            return;
        }
        
        if(_sdf->HasElement("interval"))
            interval = _sdf->GetElement("interval")->Get<double>();
        else 
            interval = 0.1;
        
        if(_sdf->HasElement("topic"))
            topic = _sdf->GetElement("topic")->Get<std::string>();
        else
            topic = "light";
        
        if(_sdf->HasElement("pixels"))
            pixelCt = _sdf->GetElement("pixels")->Get<int>();
        else
            pixelCt = 100;
        
        // get a node handle
        node = new ros::NodeHandle(namespc);
        
        // and make a timer
        timer = node->createTimer(ros::Duration(interval),
                                  &LightSensor::timerCallback,this);
        
        // and publisher(s)
        pub = node->advertise<lightsensor_gazebo::LightSensor>(topic,10);
        
        updateConnection = event::Events::ConnectWorldUpdateBegin(
                                                                  boost::bind(&LightSensor::OnUpdate,this,_1));
        
        pixelStore = new double[pixelCt*3];
        blurbuf = new double[pixelCt*3];
    }
    
    inline int hex2int(char c){
        return (c>'a') ? (c-'a')+10 : c-'0';
    }
    
    virtual void OnUpdate(const common::UpdateInfo &info){
        if(updateOK){
            lightsensor_gazebo::Pixel p;
            math::Pose myPose = link->GetWorldPose();
            double distance;
            
            // zero the temporary pixel store
            for(int i=0;i<pixelCt*3;i++)
                blurbuf[i]=0;
            
            // iterate through the objects in the world
            physics::Model_V list=world->GetModels();
            for(physics::Model_V::iterator it=list.begin();
                it!=list.end();++it){
                physics::ModelPtr ptr = *it;
                std::string name = ptr->GetName();
//                printf("Name: %s, ",(*it)->GetName().c_str());
                
                // find those with "lightrgb" in their name
                // DISTANCE CALC ASSUMES THERE'S ONLY ONE
                if(name.find("lightrgb")!=std::string::npos)
                {
                    // work out the distance of the emitter
                    // (not necessarily a box). We go from the
                    // centre.
                    math::Pose boxpose = ptr->GetWorldPose();
                    double boxx = boxpose.pos.x - myPose.pos.x;
                    double boxy = boxpose.pos.y - myPose.pos.y;
                    distance = sqrt(boxx*boxx+boxy*boxy);
                    
                    
                    printf("Distance: %f\n",distance);
                    // calculate the relative position of both corners
                    // of the AABB
                    math::Box bbox = ptr->GetBoundingBox();
                    
                    math::Vector3 v = myPose.pos - bbox.min;
                    printf("relpos1: %f,%f ",v.x,v.y);
                    double angle1 = atan2(v.y,-v.x); // angle in world space
                    angle1 += myPose.rot.GetYaw(); // convert to robot space
                    
                    v = myPose.pos - bbox.max;
                    printf("relpos2: %f,%f ",v.x,v.y);
                    double angle2 = atan2(v.y,-v.x); // angle in world space
                    
                    
                    angle2 += myPose.rot.GetYaw(); // convert to robot space
                    angle1 = fmod(angle1+6.0*PI,2.0*PI);
                    angle2 = fmod(angle2+6.0*PI,2.0*PI);
                    printf("angles: %f,%f\n",angle1,angle2);
                    
                    // rescale the angles to 0-1
                    angle1 *= 1.0/(2.0*PI);
                    angle2 *= 1.0/(2.0*PI);
                    
                    // extract the colour - it's the three chars
                    // after "lightrgb" as hex digits
                    double r = hex2int(name.at(8))*16;
                    double g = hex2int(name.at(9))*16;
                    double b = hex2int(name.at(10))*16;
                    
                    // work out the start and end pixels
                    int p1 =(int)(angle1*(double)pixelCt);
                    int p2 =  (int)(angle2*(double)pixelCt);
                    printf(" pixels1: %d,%d\n",p1,p2);
                    
                    // move "front" to the the middle and mod
                    p1 = (p1+pixelCt/2)%pixelCt;
                    p2 = (p2+pixelCt/2)%pixelCt;
                    
                    // work out the shortest route
                    int start,end;
                    if(p1>p2)std::swap(p1,p2);
                    if(p2-p1 > (p1+pixelCt)-p2){
                        // go through zero
                        start = p2;
                        end = p1+pixelCt;
                    } else {
                        start = p1;
                        end = p2;
                    }
                    
                    // add the pixels into the accumulator.
                    for(int i=start;i<=end;i++){
                        int j = i%pixelCt;
                        blurbuf[j*3+0]+=r;
                        blurbuf[j*3+1]+=g;
                        blurbuf[j*3+2]+=b;
                    }
                        
                }
            }
            
            // get the total brightness, as it should be - worked
            // out from the lookup table taken from experiments.
            
            double norm = getBrightTable(distance);
            printf("Brightness %f\n",norm);
            diamondapparatus::Topic ttt;
            ttt.add(diamondapparatus::Datum((float)norm));
            ttt.add(diamondapparatus::Datum((float)distance));
            diamondapparatus::publish("/bright",ttt);
            
            // blur added 10/10/16
            blur(pixelStore,blurbuf,0,pixelCt);
            blur(pixelStore,blurbuf,1,pixelCt);
            blur(pixelStore,blurbuf,2,pixelCt);
            
            // construct the final data and publish
            data.pixels.clear();
            for(int i=0;i<pixelCt;i++){
/*                printf("Pix %d %f %f %f\n",
                       i,
                       pixelStore[i*3+0],
                       pixelStore[i*3+1],
                       pixelStore[i*3+2]);
 */
                p.r=std::min(255.0,pixelStore[i*3+0]);
                p.g=std::min(255.0,pixelStore[i*3+1]);
                p.b=std::min(255.0,pixelStore[i*3+2]);
                data.pixels.push_back(p);
            }
            pub.publish(data);
            updateOK=false;
        }
    }

private:
    int pixelCt;
    double *pixelStore,*blurbuf;
    lightsensor_gazebo::LightSensor data;
    
    physics::ModelPtr model;
    physics::WorldPtr world;
    physics::LinkPtr link;
    event::ConnectionPtr updateConnection;
    std::string linkname;
    
    ros::NodeHandle *node;
    ros::Publisher pub;
    ros::Timer timer;
    std::string namespc;
    std::string topic;
    double interval;
};

GZ_REGISTER_MODEL_PLUGIN(LightSensor)
}
